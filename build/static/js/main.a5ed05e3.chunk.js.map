{"version":3,"sources":["api/index.js","components/Feature.js","components/Loading.js","components/Preview.js","components/Search.js","components/Title.js","index.js"],"names":["BASE_URL","KEY","fetchQueryResultsFromTermAndValue","term","value","a","fetch","encodeURI","split","join","response","json","data","fetchQueryResultsFromURL","url","fetchQueryResults","century","classification","queryString","fetchAllCenturies","localStorage","getItem","JSON","parse","records","setItem","stringify","fetchAllClassifications","Searchable","props","searchTerm","setIsLoading","setSearchResults","searchValue","id","onSubmit","event","preventDefault","results","console","error","Feature","featuredResult","title","dated","images","primaryimageurl","description","culture","style","technique","medium","dimensions","people","department","division","contact","creditline","className","Fragment","map","person","key","displayname","length","image","toString","src","baseimageurl","alt","Loading","Preview","setFeaturedResult","searchResults","info","fetchPage","pageUrl","disabled","prev","onClick","next","record","index","Search","useState","centuryList","setCenturyList","classificationList","setClassificationList","setQueryString","setCentury","setClassification","useEffect","Promise","all","then","centuries","catch","log","htmlFor","type","placeholder","onChange","target","name","idx","Title","App","isLoading","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.a5ed05e3.chunk.js","sourcesContent":["/**\n * This file features and exports all of your calls to the API\n * \n * You need to replace YOUR_API_KEY in the string associated with KEY with your actual API key\n */\nexport const BASE_URL = 'https://api.harvardartmuseums.org';\nexport const KEY = 'apikey=48e4145f-9ba2-48c9-9976-b0710b0ef763';\n\n/**\n * This will make a call to the API for a single term and value (e.g. \"person\", and \"unknown\"), and return the result. \n * If we do not have async, we cannot fetch. The function will grab information \"the term\" typed in and grab it from the database. \n */\nexport async function fetchQueryResultsFromTermAndValue(term, value) {\n  try {\n    const response = await fetch(`${ BASE_URL }/object?${ KEY }&${ term }=${ encodeURI(value.split('-').join('|')) }`);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This will make a call to the API for a preformed url (useful for previous and next buttons), and return the result.\n * This function is expecting you to pass in the specific URL you want to use. \n */\nexport async function fetchQueryResultsFromURL(url) {\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * Requires an object { century: '', classification: '', queryString: '' } to be passed in as an argument\n * \n * Then makes a call to the API, and returns the first page of results\n * Searches the database based on century and classification.\n */\nexport async function fetchQueryResults({\n  century,\n  classification,\n  queryString,\n}) {\n  const url = `${ BASE_URL }/object?${ KEY }&classification=${ classification }&century=${ \n    century }&keyword=${ queryString }`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n\n    return data;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are centuries stored in localStorage, or fetches them from the API and stores them in localStorage if not\n * This function is for searching the database for a specific century in a certain order. This function does not use any query. \n *  The first time the function is called, it is saved to local storage (JSON). The second time it will not rerun, it will just go back to the API and pull it from there.\n */\nexport async function fetchAllCenturies() {\n  if (localStorage.getItem('centuries')) {\n    return JSON.parse(localStorage.getItem('centuries'));\n  }\n\n  const url = `${ BASE_URL }/century?${ KEY }&size=100&sort=temporalorder`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('centuries', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * This returns early if there are classifications stored in localStorage, or fetches them from the API and stores them in localStorage if not \n * This function is for searching the database for a specific classification in a certain order. This function does not use any query. \n * The first time the function is called, it is saved to local storage (JSON). The second time it will not rerun, it will just go back to the API and pull it from there.\n */\nexport async function fetchAllClassifications() {\n  if (localStorage.getItem('classifications')) {\n    return JSON.parse(localStorage.getItem('classifications'));\n  }\n\n  const url = `${ BASE_URL }/classification?${ KEY }&size=100&sort=name`;\n\n  try {\n    const response = await fetch(url);\n    const data = await response.json();\n    const records = data.records;\n\n    localStorage.setItem('classifications', JSON.stringify(records));\n\n    return records;\n  } catch (error) {\n    throw error;\n  }\n}","import React, { Fragment } from 'react';\n\n// Don't touch this import\nimport { fetchQueryResultsFromTermAndValue } from '../api';\n\n/**\n * We need a new component called Searchable which:\n * \n * Has a template like this:\n * \n * <span className=\"content\">\n *  <a href=\"#\" onClick={async (event) => {}}>SOME SEARCH TERM</a>\n * </span>\n *\n * You'll need to read searchTerm, searchValue, setIsLoading, and setSearchResults off of the props.\n * DESTRUCTURE THE ABOVE^^^^\n * const {\n  setIsLoading,\n  setSearchResults,\n  setFeaturedResult\n  } = props\n * \n * When someone clicks the anchor tag, you should:\n * \n * - preventDefault on the event\n * - call setIsLoading, set it to true\n * \n * Then start a try/catch/finally block:\n * \n * try:\n *  - await the result of fetchQueryResultsFromTermAndValue, passing in searchTerm and searchValue\n *  - send the result to setSearchResults (which will update the Preview component)\n * catch: \n *  - console.error the error\n * finally:\n *  - call setIsLoading, set it to false\n * EXAMPLE:\n * return <form id=\"search\" onSubmit={async (event) => {\n        event.preventDefault()\n        setIsLoading(true)\n\n       try{\n        const results = await fetchQueryResults({\n          century,\n          classification,\n          queryString\n        });\n\n        setSearchResults(response);\n       }\n      catch (error) {\n        console.error();\n      }\n      finally {\n        setIsLoading(false);\n      }\n     }}\n */\n// You'll need to read searchTerm, searchValue, setIsLoading, and setSearchResults off of the props.\nconst Searchable = (props) => {\n      const {\n        searchTerm,\n        setIsLoading,\n        setSearchResults,\n        searchValue\n  } = props\n  \n\nreturn <a id=\"search\" onSubmit={async (event) => {\n        event.preventDefault()\n        setIsLoading(true)\n\n       try{\n        const results = await fetchQueryResultsFromTermAndValue({\n          searchTerm,\n          searchValue,\n        });\n\n        setSearchResults(results);\n       }\n      catch (error) {\n        console.error();\n      }\n      finally {\n        setIsLoading(false);\n      }\n     }}>{searchTerm}</a>\n    }\n/**\n * We need a new component called Feature which looks like this when no featuredResult is passed in as a prop:\n * \n * <main id=\"feature\"></main>\n * \n * And like this when one is:\n * \n * <main id=\"feature\">\n *   <div className=\"object-feature\">\n *     <header>\n *       <h3>OBJECT TITLE</h3>\n *       <h4>WHEN IT IS DATED</h4>\n *     </header>\n *     <section className=\"facts\">\n *       <span className=\"title\">FACT NAME</span>\n *       <span className=\"content\">FACT VALUE</span>\n *       <span className=\"title\">NEXT FACT NAME</span>\n *       <span className=\"content\">NEXT FACT VALUE</span>\n *     </section>\n *     <section className=\"photos\">\n *       <img src=IMAGE_URL alt=SOMETHING_WORTHWHILE />\n *     </section>\n *   </div>\n * </main>\n * \n * The different facts look like this: title, dated, images, primaryimageurl, description, culture, style, \n * technique, medium, dimensions, people, department, division, contact, creditline\n * \n * The <Searchable /> ones are: culture, technique, medium (first toLowerCase it), and person.displayname (one for each PEOPLE)\n * \n * NOTE: people and images are likely to be arrays, and will need to be mapped over if they exist\n * \n * This component should be exported as default.\n * \n * The <tr> HTML element defines a row of cells in a table. \n * The row's cells can then be established using a mix of <td> (data cell) and <th> (header cell) elements.\n */\n\nconst Feature = (props) => {\n  const { featuredResult } = props;\n  if (!featuredResult) {\n    return <main id=\"feature\"></main>;\n  } else {\n    const { title, dated, images, primaryimageurl, description, culture, style, technique, medium, dimensions, people, department, division, contact, creditline } = featuredResult;\n    return (\n      <main id=\"feature\">\n        <div className=\"object-feature\">\n          <header>\n            <h3>{title}</h3>\n            <h4>{dated}</h4>\n          </header>\n          <section className=\"facts\">\n            {description ? (\n              <React.Fragment>\n                <span className=\"title\">Description</span>\n                <span className=\"content\">{description}</span>\n              </React.Fragment>\n            ) : null}\n            {culture ? (\n              <React.Fragment>\n                <span className=\"title\">Culture</span>\n                <Searchable searchValue={culture} searchTerm={\"culture\"} {...props} />\n              </React.Fragment>\n            ) : null}\n            {style ? (\n              <React.Fragment>\n                <span className=\"title\">Style</span>\n                <span className=\"content\">{style}</span>\n              </React.Fragment>\n            ) : null}\n            {technique ? (\n              <React.Fragment>\n                <span className=\"title\">Technique</span>\n                <Searchable searchValue={technique} searchTerm={\"technique\"} {...props}/>\n              </React.Fragment>\n            ) : null}\n            {medium ? (\n              <React.Fragment>\n                <span className=\"title\">Medium</span>\n                <Searchable searchValue={medium} searchTerm={\"medium\"} {...props}/>\n              </React.Fragment>\n            ) : null}\n            {dimensions ? (\n              <React.Fragment>\n                <span className=\"title\">Dimensions</span>\n                <span className=\"content\">{dimensions}</span>\n              </React.Fragment>\n            ) : null}\n            {people ? (\n              <React.Fragment>\n                <span className=\"title\">People</span>\n                {people.map((person)=> (<Searchable key={person.displayname} searchValue={person.displayname} searchTerm={\"person\"} {...props}/>))}\n              </React.Fragment>\n            ) : null}\n            {department ? (\n              <React.Fragment>\n                <span className=\"title\">Department</span>\n                <span className=\"content\">{department}</span>\n              </React.Fragment>\n            ) : null}\n            {division ? (\n              <React.Fragment>\n                <span className=\"title\">Division</span>\n                <span className=\"content\">{division}</span>\n              </React.Fragment>\n            ) : null}\n            {contact ? (\n              <React.Fragment>\n                <span className=\"title\">Contact</span>\n                <span className=\"content\">{contact}</span>\n              </React.Fragment>\n            ) : null}\n            {creditline ? (\n              <React.Fragment>\n                <span className=\"title\">Credit</span>\n                <span className=\"content\">{creditline}</span>\n              </React.Fragment>\n            ) : null}\n          </section>\n          <section className=\"photos\">\n          {images.length > 0 ? (\n            images.map((image) => {\n              return (\n                <img\n                  key={image.toString}\n                  src={image.baseimageurl}\n                  alt={description}\n                />\n              );\n            })\n          ) : (\n            <img src={primaryimageurl} alt={description} />\n          )}\n          </section>\n        </div>\n      </main>\n    );\n  }\n};\nexport default Feature;","import React from 'react';\n\n/**\n * Create and export a component called Loading which uses this static HTML template:\n * \n * <div id=\"loading\">\n *   <h2 className=\"message\">Searching...</h2>\n * </div>\n */\n\nconst Loading = () => {\n    return <div id=\"loading\">\n      <h2 className=\"message\">Searching...</h2>\n    </div>\n}\n\nexport default Loading;","import React from \"react\";\n\n/**\n * We need to import fetchQueryResultsFromURL since we will sometimes have urls in info.prev and info.next\n * which are query urls.\n */\nimport { fetchQueryResultsFromURL } from \"../api\";\n\nconst Preview = (props) => {\n  /**\n   * Destructure setSearchResults, setFeaturedResult, and setIsLoading from props\n   * and also destructure info and records from props.searchResults\n   *\n   * You need info, records, setSearchResults, setFeaturedResult, and setIsLoading as available constants\n   */\n\n  const { setSearchResults, setFeaturedResult, setIsLoading } = props;\n\n  const { info, records } = props.searchResults;\n\n  /**\n   * Don't touch this function, it's good to go.\n   *\n   * It has to be defined inside the Preview component to have access to setIsLoading, setSearchResults, etc...\n   */\n  async function fetchPage(pageUrl) {\n    setIsLoading(true);\n\n    try {\n      const results = await fetchQueryResultsFromURL(pageUrl);\n      setSearchResults(results);\n    } catch (error) {\n      console.error(error);\n    } finally {\n      setIsLoading(false);\n    }\n  }\n\n  const renderPreviewImage = function (record) {\n    if (record.primaryimageurl) {\n      return <img src={record.primaryimageurl} alt={record.description} />;\n    }\n    return;\n  };\n\n  const renderPreviewTitle = (record) => {\n    if (record.title) {\n      return <h3>{record.title}</h3>;\n    } else {\n      return <h3>MISSING INFO</h3>;\n    }\n  };\n\n  return (\n    <aside id=\"preview\">\n      <header className=\"pagination\">\n        <button\n          disabled={!info.prev}\n          className=\"previous\"\n          onClick={() => fetchPage(info.prev)}\n        >\n          Previous\n        </button>\n\n        <button\n          disabled={!info.next}\n          className=\"next\"\n          onClick={() => fetchPage(info.next)}\n        >\n          Next\n        </button>\n      </header>\n\n      <section className=\"results\">\n        {records.map((record, index) => (\n          <div\n            key={index}\n            className=\"object-preview\"\n            onClick={(event) => {\n              event.preventDefault();\n              setFeaturedResult(record);\n            }}\n          >\n            record.primaryimageurl ?{\" \"}\n            <img src={record.primaryimageurl} alt={record.description} /> : null\n            {record.title ? <h3>{record.title}</h3> : <h3>MISSING INFO</h3>}\n          </div>\n        ))}\n      </section>\n    </aside>\n  );\n};\n\nexport default Preview;\n","import React, { useEffect, useState } from 'react';\n\n/**\n * Don't touch these imports!\n */\nimport { \n  fetchAllCenturies,\n  fetchAllClassifications,\n  fetchQueryResults\n} from '../api';\n\nconst Search = (props) => {\n  // Make sure to destructure setIsLoading and setSearchResults from the props\n  // For example, I know that this props object has setIsLoading, setSearchResults, and setFeaturedResult. There methods are functions. \n  // <Search setIsLoading={setIsLoading} setSearchResults={setSearchResult} setFeaturedResult={setFeaturedResult}/>\n  // For example, whatever we pass into setSearchResults is going to update seachResults. const [searchResults, setSearchResults] = useState({info {}, records: []} )\n  // Destructured our props \n\n  const {\n  setIsLoading,\n  setSearchResults,\n  setFeaturedResult\n  } = props\n\n  /**\n   * We are at the Search component, a child of app. This has a form, so we need to use useState for\n   * our controlled inputs:\n   * Set up our states and values for everything listed below.\n   * centuryList, setCenturyList (default should be an empty array, [])\n   * classificationList, setClassificationList (default should be an empty array, [])\n   * queryString, setQueryString (default should be an empty string, '')\n   * century, setCentury (default should be the string 'any')\n   * classification, setClassification (default should be the string 'any')\n   */\n  // created our state variables\n  const [centuryList, setCenturyList] = useState([])\n  const [classificationList, setClassificationList] = useState([])\n  const [queryString, setQueryString] = useState('')\n  const [century, setCentury] = useState('any')\n  const [classification, setClassification] = useState('any')\n\n\n  /**\n   * Inside of useEffect, use Promise.all([]) with fetchAllCenturies and fetchAllClassifications\n   * \n   * In the .then() callback pass the returned lists to setCenturyList and setClassificationList\n   * \n   * Make sure to console.error on caught errors from the API methods.\n   * \n   * What does useEffect do? By using this Hook, you tell React that your component needs to do something after render.\n   * React will remember the function you passed (we'll refer to it as our “effect”), and call it later after performing the DOM updates.\n   * useEffect Hook is used to eliminate the side-effects of using class-based components. The Effect Hook lets you perform side effects in function components. \n   * In useEffect we will do all the API calls. Inside the array every function you want to run as a promise.\n   * FetchAllCenturies and FetchAllClassifications we get from the API which has already been imported for us.\n   * Inside of Promise.all, we give it an array. Then, every array is a function you want to run as a promise. This will automatically does the wait for you. \n   */\n\n  \n\n  useEffect(() => {\n    Promise.all(\n      [\n      fetchAllCenturies(),\n      fetchAllClassifications()\n      ]\n    )\n    .then(([centuries, classifications]) => {\n      setCenturyList(centuries)\n      setClassificationList(classificationList)\n\n    }) \n    .catch(console.error)\n  \n  }, []);\n\n  /**\n   * This is a form element, so we need to bind an onSubmit handler to it which:\n   * \n   * calls event.preventDefault()\n   * calls setIsLoading, set it to true\n   * \n   * then, in a try/catch/finally block:\n   * \n   * try to:\n   * - get the results from fetchQueryResults({ century, classification, queryString })\n   * - pass them to setSearchResults\n   * \n   * catch: error to console.error\n   * \n   * finally: call setIsLoading, set it to false\n   */\n  \n  const handleClassificationChange = (event) => setClassification(event.target.value);\n  const handleQueryChange = (event) => setQueryString(event.target.value);\n  const handleSetCentury = (event) => setCentury(event.target.value);\n  console.log(centuryList);\n  console.log(classificationList);\n\n   return <form id=\"search\" onSubmit={async (event) => {\n        event.preventDefault()\n        setIsLoading(true)\n\n       try{\n        const results = await fetchQueryResults({\n          century,\n          classification,\n          queryString\n        });\n\n        setSearchResults(results);\n       }\n      catch (error) {\n        console.error();\n      }\n      finally {\n        setIsLoading(false);\n      }\n     }}\n  >\n    <fieldset>\n      <label htmlFor=\"keywords\">Query</label>\n      <input \n        id=\"keywords\" \n        type=\"text\" \n        placeholder=\"enter keywords...\" \n        value={queryString} \n         onChange={(event) => {\n           setQueryString(event.target.value)\n          }} />\n\n    </fieldset>\n    <fieldset>\n      <label htmlFor=\"select-classification\">Classification <span className=\"classification-count\">({ classificationList.length })</span></label>\n      <select \n        name=\"classification\"\n        id=\"select-classification\"\n        value={classification} \n         onChange={(event) => {\n           setClassification(event.target.value)\n          }}>\n         <option value=\"any\">Any</option>\n\n         {classificationList.map((classification, idx) => \n            <option key={'${idx}:${classification.name}'} value={classification.name}>\n              {classification.name}\n            </option>)}\n\n    </select>\n    </fieldset>\n    <fieldset>\n      <label htmlFor=\"select-century\">Century <span className=\"century-count\">({ centuryList.length })</span></label>\n      <select \n        name=\"century\" \n        id=\"select-century\"\n        value={century} \n         onChange={(event) => setCentury(event.target.value)}>\n          {century.name}\n        <option value=\"any\">Any</option>\n        {centuryList.map((century, idx) => \n          <option key={'$(idx):${century.name}'} value={century.name}>\n            {century.name}\n          </option>)}\n       </select>\n     </fieldset>\n    <button>SEARCH</button>\n  </form>\n}\nexport default Search;","import React from 'react';\n\n/**\n * Create/export a component called Title which uses this static HTML as the template:\n * \n * <div id=\"title\">\n *   <h1>\n *     The Art Collector\n *   </h1>\n *   <h5>\n *     Search the Harvard Art Museums' Private Collections\n *   </h5>\n * </div>\n */\n\nconst Title = () => {\n    return (<div id=\"title\">\n        <h1>\n             The Art Collector\n        </h1>\n        <h5>\n            Search the Harvard Art Museums' Private Collections\n        </h5>\n  </div>)\n} \n\nexport default Title;","import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\n\n// These imports won't work until you fix ./components/index.js\nimport {\n  Feature,\n  Loading,\n  Preview,\n  Search,\n  Title\n} from './components';\n\nconst App = () => {\n  /**\n   * We are at the App level component, which is top-most. Any state which needs to be shared between immediate children should\n   * be made here, so create state pairs using useState() for:\n   * \n   * searchResults, setSearchResults (default should be this object:  ({info: {}, records: []} )\n   * featuredResult, setFeaturedResult (default should be null)\n   * isLoading, setIsLoading (default should be false)\n   */\n\n    const [searchResults, setSearchResults] = useState({info: {}, records: []} )\n  // object that has 2 properties in it. These are just built in methods to \"useState\" to update whatever we set there. \n    const [featuredResult, setFeaturedResult] = useState(null)\n    const [isLoading, setIsLoading] = useState(false)\n\n  return <div className=\"app\">\n    {/* <Title /> is static, doesn't need any props */}\n    <Title />\n    {/* <Search /> needs props for setIsLoading and setSearchResults (trigger <Loading /> on search start/end, and transfer results to preview) */}\n    <Search setIsLoading={setIsLoading} setSearchResults={setSearchResults} setFeaturedResult={setFeaturedResult}/>\n    {/* <Preview /> needs props for searchResults, setIsLoading and setSearchResults (clicking prev/next buttons), and setFeaturedResult (clicking a preview) */}\n    {<Preview searchResults={searchResults} setIsLoading={setIsLoading} setSearchResults={setSearchResults} setFeaturedResult={setFeaturedResult}/> }\n    {/* <Feature /> needs props for featuredResult, as well as setIsLoading and setSearchResults (clicking on searchable properties) */}\n    { <Feature featuredResult={featuredResult} setIsLoading={setIsLoading} setSearchResults={setSearchResults} />}\n    {/* <Loading /> is static, but should only render when isLoading is true */}\n    {/* ternary operator is a short hand \"if else\" */}\n    {/* use a ternary and render null if isLoading is false. isLoading ? is checking to see if it is true or false. If it is true, <Loading /> is our first value. */}\n    {/* If it is false, null is our second value. */}\n    {\n    isLoading ? <Loading />: null\n    } \n  </div>\n}\n\n/**\n * Boostrap the <App /> component into the '#app' element in the DOM,\n * using ReactDOM.render();\n */\n\nReactDOM.render(<App />, document.getElementById('app'))"],"sourceRoot":""}